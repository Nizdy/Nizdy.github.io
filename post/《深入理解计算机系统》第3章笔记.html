<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"nizdy.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"livere","storage":true,"lazyload":false,"nav":null,"activeClass":"livere"},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="第三章 程序的机器级表示3.2 程序编码计算机的抽象模型     计算机的抽象模型，是计算机利用更简单的抽象模型来隐藏实现的细节。对于机器级编程来说，其中两种抽象尤为重要。第一种是由指令集体系结构或指令集架构（ Instruction Set Architecture,ISA）来定义机器级程序的格式和行为，它定义了处理器状态、指令的格式，以及每条指令对状态的影响。大多数ISA，包括x86-64，将">
<meta property="og:type" content="article">
<meta property="og:title" content="《深入理解计算机系统》第3章笔记">
<meta property="og:url" content="https://nizdy.github.io/post/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E3%80%8B%E7%AC%AC3%E7%AB%A0%E7%AC%94%E8%AE%B0.html">
<meta property="og:site_name" content="Nizdy&#39;s Blog">
<meta property="og:description" content="第三章 程序的机器级表示3.2 程序编码计算机的抽象模型     计算机的抽象模型，是计算机利用更简单的抽象模型来隐藏实现的细节。对于机器级编程来说，其中两种抽象尤为重要。第一种是由指令集体系结构或指令集架构（ Instruction Set Architecture,ISA）来定义机器级程序的格式和行为，它定义了处理器状态、指令的格式，以及每条指令对状态的影响。大多数ISA，包括x86-64，将">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://nizdy.github.io/post/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E3%80%8B%E7%AC%AC3%E7%AB%A0%E7%AC%94%E8%AE%B0/3.1.png">
<meta property="og:image" content="https://nizdy.github.io/post/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E3%80%8B%E7%AC%AC3%E7%AB%A0%E7%AC%94%E8%AE%B0/3.2.png">
<meta property="og:image" content="https://nizdy.github.io/post/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E3%80%8B%E7%AC%AC3%E7%AB%A0%E7%AC%94%E8%AE%B0/3.3.png">
<meta property="og:image" content="https://nizdy.github.io/post/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E3%80%8B%E7%AC%AC3%E7%AB%A0%E7%AC%94%E8%AE%B0/3.4.png">
<meta property="og:image" content="https://nizdy.github.io/post/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E3%80%8B%E7%AC%AC3%E7%AB%A0%E7%AC%94%E8%AE%B0/3.5.png">
<meta property="og:image" content="https://nizdy.github.io/post/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E3%80%8B%E7%AC%AC3%E7%AB%A0%E7%AC%94%E8%AE%B0/3.6.png">
<meta property="og:image" content="https://nizdy.github.io/post/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E3%80%8B%E7%AC%AC3%E7%AB%A0%E7%AC%94%E8%AE%B0/3.7.png">
<meta property="og:image" content="https://nizdy.github.io/post/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E3%80%8B%E7%AC%AC3%E7%AB%A0%E7%AC%94%E8%AE%B0/3.8.png">
<meta property="og:image" content="https://nizdy.github.io/post/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E3%80%8B%E7%AC%AC3%E7%AB%A0%E7%AC%94%E8%AE%B0/3.9.png">
<meta property="og:image" content="https://nizdy.github.io/post/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E3%80%8B%E7%AC%AC3%E7%AB%A0%E7%AC%94%E8%AE%B0/3.10.png">
<meta property="og:image" content="https://nizdy.github.io/post/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E3%80%8B%E7%AC%AC3%E7%AB%A0%E7%AC%94%E8%AE%B0/3.11.png">
<meta property="og:image" content="https://nizdy.github.io/post/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E3%80%8B%E7%AC%AC3%E7%AB%A0%E7%AC%94%E8%AE%B0/3.12.png">
<meta property="og:image" content="https://nizdy.github.io/post/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E3%80%8B%E7%AC%AC3%E7%AB%A0%E7%AC%94%E8%AE%B0/3.13.png">
<meta property="og:image" content="https://nizdy.github.io/post/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E3%80%8B%E7%AC%AC3%E7%AB%A0%E7%AC%94%E8%AE%B0/3.14.png">
<meta property="og:image" content="https://nizdy.github.io/post/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E3%80%8B%E7%AC%AC3%E7%AB%A0%E7%AC%94%E8%AE%B0/3.15.png">
<meta property="og:image" content="https://nizdy.github.io/post/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E3%80%8B%E7%AC%AC3%E7%AB%A0%E7%AC%94%E8%AE%B0/3.16.png">
<meta property="og:image" content="https://nizdy.github.io/post/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E3%80%8B%E7%AC%AC3%E7%AB%A0%E7%AC%94%E8%AE%B0/3.17.png">
<meta property="og:image" content="https://nizdy.github.io/post/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E3%80%8B%E7%AC%AC3%E7%AB%A0%E7%AC%94%E8%AE%B0/3.18.png">
<meta property="og:image" content="https://nizdy.github.io/post/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E3%80%8B%E7%AC%AC3%E7%AB%A0%E7%AC%94%E8%AE%B0/3.19.png">
<meta property="og:image" content="https://nizdy.github.io/post/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E3%80%8B%E7%AC%AC3%E7%AB%A0%E7%AC%94%E8%AE%B0/3.20.png">
<meta property="og:image" content="https://nizdy.github.io/post/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E3%80%8B%E7%AC%AC3%E7%AB%A0%E7%AC%94%E8%AE%B0/3.21.png">
<meta property="og:image" content="https://nizdy.github.io/post/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E3%80%8B%E7%AC%AC3%E7%AB%A0%E7%AC%94%E8%AE%B0/3.22.png">
<meta property="og:image" content="https://nizdy.github.io/post/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E3%80%8B%E7%AC%AC3%E7%AB%A0%E7%AC%94%E8%AE%B0/3.23.png">
<meta property="og:image" content="https://nizdy.github.io/post/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E3%80%8B%E7%AC%AC3%E7%AB%A0%E7%AC%94%E8%AE%B0/3.24.png">
<meta property="og:image" content="https://nizdy.github.io/post/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E3%80%8B%E7%AC%AC3%E7%AB%A0%E7%AC%94%E8%AE%B0/3.25.png">
<meta property="og:image" content="https://nizdy.github.io/post/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E3%80%8B%E7%AC%AC3%E7%AB%A0%E7%AC%94%E8%AE%B0/3.26.png">
<meta property="og:image" content="https://nizdy.github.io/post/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E3%80%8B%E7%AC%AC3%E7%AB%A0%E7%AC%94%E8%AE%B0/3.27.png">
<meta property="og:image" content="https://nizdy.github.io/post/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E3%80%8B%E7%AC%AC3%E7%AB%A0%E7%AC%94%E8%AE%B0/3.28.png">
<meta property="og:image" content="https://nizdy.github.io/post/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E3%80%8B%E7%AC%AC3%E7%AB%A0%E7%AC%94%E8%AE%B0/3.29.png">
<meta property="og:image" content="https://nizdy.github.io/post/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E3%80%8B%E7%AC%AC3%E7%AB%A0%E7%AC%94%E8%AE%B0/3.30.png">
<meta property="og:image" content="https://nizdy.github.io/post/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E3%80%8B%E7%AC%AC3%E7%AB%A0%E7%AC%94%E8%AE%B0/3.31.png">
<meta property="og:image" content="https://nizdy.github.io/post/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E3%80%8B%E7%AC%AC3%E7%AB%A0%E7%AC%94%E8%AE%B0/3.32.png">
<meta property="og:image" content="https://nizdy.github.io/post/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E3%80%8B%E7%AC%AC3%E7%AB%A0%E7%AC%94%E8%AE%B0/3.33.png">
<meta property="og:image" content="https://nizdy.github.io/post/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E3%80%8B%E7%AC%AC3%E7%AB%A0%E7%AC%94%E8%AE%B0/3.34.png">
<meta property="og:image" content="https://nizdy.github.io/post/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E3%80%8B%E7%AC%AC3%E7%AB%A0%E7%AC%94%E8%AE%B0/3.35.png">
<meta property="og:image" content="https://nizdy.github.io/post/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E3%80%8B%E7%AC%AC3%E7%AB%A0%E7%AC%94%E8%AE%B0/3.36.png">
<meta property="og:image" content="https://nizdy.github.io/post/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E3%80%8B%E7%AC%AC3%E7%AB%A0%E7%AC%94%E8%AE%B0/3.37.png">
<meta property="og:image" content="https://nizdy.github.io/post/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E3%80%8B%E7%AC%AC3%E7%AB%A0%E7%AC%94%E8%AE%B0/3.38.png">
<meta property="og:image" content="https://nizdy.github.io/post/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E3%80%8B%E7%AC%AC3%E7%AB%A0%E7%AC%94%E8%AE%B0/3.39.png">
<meta property="og:image" content="https://nizdy.github.io/post/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E3%80%8B%E7%AC%AC3%E7%AB%A0%E7%AC%94%E8%AE%B0/6014302c6ca4a998546deba9bfb7d21f.png">
<meta property="og:image" content="https://nizdy.github.io/post/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E3%80%8B%E7%AC%AC3%E7%AB%A0%E7%AC%94%E8%AE%B0/8aeb1adc70544c510f9c12d9feb09264.png">
<meta property="og:image" content="https://nizdy.github.io/post/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E3%80%8B%E7%AC%AC3%E7%AB%A0%E7%AC%94%E8%AE%B0/529c2f38d4fd25856f828cc09f02760c.png">
<meta property="og:image" content="https://nizdy.github.io/post/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E3%80%8B%E7%AC%AC3%E7%AB%A0%E7%AC%94%E8%AE%B0/d9291f28812b71aedfd466806cea181a.png">
<meta property="og:image" content="https://nizdy.github.io/post/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E3%80%8B%E7%AC%AC3%E7%AB%A0%E7%AC%94%E8%AE%B0/b50d94d89e186838d37ee9e342e376de.png">
<meta property="og:image" content="https://nizdy.github.io/post/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E3%80%8B%E7%AC%AC3%E7%AB%A0%E7%AC%94%E8%AE%B0/850fa8db462b3ed22eb5ac768fe81b98.png">
<meta property="og:image" content="https://nizdy.github.io/post/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E3%80%8B%E7%AC%AC3%E7%AB%A0%E7%AC%94%E8%AE%B0/6861bf8fb1eb47a6bd7cd3a7f9be33c4.png">
<meta property="og:image" content="https://nizdy.github.io/post/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E3%80%8B%E7%AC%AC3%E7%AB%A0%E7%AC%94%E8%AE%B0/e95b5aa82e8cb2dbbee2887045f9c7bd.png">
<meta property="og:image" content="https://nizdy.github.io/post/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E3%80%8B%E7%AC%AC3%E7%AB%A0%E7%AC%94%E8%AE%B0/362a0229b6ab79d0dd5adbf3a2c37897.png">
<meta property="og:image" content="https://nizdy.github.io/post/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E3%80%8B%E7%AC%AC3%E7%AB%A0%E7%AC%94%E8%AE%B0/9ccbe5e6e313ae3f6b0b7b8373698ebf.png">
<meta property="og:image" content="https://nizdy.github.io/post/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E3%80%8B%E7%AC%AC3%E7%AB%A0%E7%AC%94%E8%AE%B0/d8f741dc2ac1d35590d05b5d95b60630.png">
<meta property="og:image" content="https://nizdy.github.io/post/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E3%80%8B%E7%AC%AC3%E7%AB%A0%E7%AC%94%E8%AE%B0/e3367b1173bd3abfc4957a85765c0a65.png">
<meta property="og:image" content="https://nizdy.github.io/post/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E3%80%8B%E7%AC%AC3%E7%AB%A0%E7%AC%94%E8%AE%B0/77c82b0ca2833fb07f330017c47b70fd.png">
<meta property="article:published_time" content="2021-06-30T10:10:09.000Z">
<meta property="article:modified_time" content="2021-07-04T04:02:55.392Z">
<meta property="article:author" content="Nizdy">
<meta property="article:tag" content="笔记">
<meta property="article:tag" content="深入理解计算机系统">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://nizdy.github.io/post/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E3%80%8B%E7%AC%AC3%E7%AB%A0%E7%AC%94%E8%AE%B0/3.1.png">

<link rel="canonical" href="https://nizdy.github.io/post/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E3%80%8B%E7%AC%AC3%E7%AB%A0%E7%AC%94%E8%AE%B0.html">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>《深入理解计算机系统》第3章笔记 | Nizdy's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Nizdy's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Nizdy 的学习世界 (づ ●─● )づ</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://nizdy.github.io/post/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E3%80%8B%E7%AC%AC3%E7%AB%A0%E7%AC%94%E8%AE%B0.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Nizdy">
      <meta itemprop="description" content="(눈_눈)">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Nizdy's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          《深入理解计算机系统》第3章笔记
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-06-30 18:10:09" itemprop="dateCreated datePublished" datetime="2021-06-30T18:10:09+08:00">2021-06-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-07-04 12:02:55" itemprop="dateModified" datetime="2021-07-04T12:02:55+08:00">2021-07-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E3%80%8B%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">《深入理解计算机系统》笔记</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="第三章-程序的机器级表示"><a href="#第三章-程序的机器级表示" class="headerlink" title="第三章 程序的机器级表示"></a>第三章 程序的机器级表示</h1><h2 id="3-2-程序编码"><a href="#3-2-程序编码" class="headerlink" title="3.2 程序编码"></a>3.2 程序编码</h2><h4 id="计算机的抽象模型"><a href="#计算机的抽象模型" class="headerlink" title="计算机的抽象模型"></a>计算机的抽象模型</h4><p>     计算机的抽象模型，是计算机利用更简单的抽象模型来隐藏实现的细节。对于机器级编程来说，其中<strong>两种抽象尤为重要</strong>。第一种是由<strong>指令集体系结构或指令集架构</strong>（ Instruction Set Architecture,ISA）来定义机器级程序的格式和行为，它定义了<strong>处理器状态</strong>、<strong>指令的格式</strong>，以及<strong>每条指令对状态的影响</strong>。大多数ISA，包括x86-64，将程序的行为描述成<strong>好像每条指令都是按顺序执行的</strong>，一条指令结束后，下一条再开始。处理器的硬件远比描述的精细复杂，它们并发地执行许多指令，但是可以采取措施保证整体行为与ISA指定的顺序执行的行为完全一致。第二种抽象是，<strong>机器级程序使用的内存地址是虚拟地址，提供的内存模型看上去是一个非常大的字节数组</strong>。存储器系统的实际实现是将多个硬件存储器和操作系统软件组合起来。</p>
<h4 id="汇编代码中的寄存器"><a href="#汇编代码中的寄存器" class="headerlink" title="汇编代码中的寄存器"></a>汇编代码中的寄存器</h4><p>  程序计数器（通常称为“PC”，在x86-64中用号%rip表示）给出将要执行的下一条指令在内存中的地址。</p>
<p>  整数寄存器文件包含16个命名的位置，分别存储64位的值。这些寄存器可以存储地址（对应于C语言的指针）或整数数据。有的寄存器被用来记录某些重要的程序状态，而其他的寄存器用来保存临时数据，例如过程的参数和局部变量，以及函数的返回值。</p>
<p>  条件码寄存器保存着最近执行的算术或逻辑指令的状态信息。它们用来实现控制或数据流中的条件变化，比如说用来实现if和 while语句</p>
<p>  一组向量寄存器可以存放个或多个整数或浮点数值</p>
<p>  <strong>关于汇编中常用的寄存器建议看我整理的嵌入式软件开发面试知识点中的ARM部分，里面详细介绍了Arm中常用的寄存器和指令集。</strong></p>
<h4 id="机器代码示例"><a href="#机器代码示例" class="headerlink" title="机器代码示例"></a>机器代码示例</h4><p>  假如我们有一个main.c文件，使用 gcc -0g -S main.c可以产生一个汇编文件。接着使用gcc -0g -c  main.c就可以产生目标代码文件main.o。通常，这个.o文件是二进制格式的，无法直接查看，我们打开编辑器可以调整为十六进制的格式，示例如下所示。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">53</span> <span class="number">48</span> <span class="number">89</span> d3 e8 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">48</span> <span class="number">89</span> <span class="number">03</span> <span class="number">5b</span> c3</span><br></pre></td></tr></table></figure>

<p>  这就是汇编指令对应的<strong>目标代码</strong>。从中得到一个重要信息，即<strong>机器执行的程序只是一个字节序列，它是对一系列指令的编码。机器对产生这些指令的源代码几乎一无所知。</strong></p>
<h4 id="反汇编简介"><a href="#反汇编简介" class="headerlink" title="反汇编简介"></a>反汇编简介</h4><p>  要查看机器代码文件的内容，有一类称为反汇编器（ disassembler）的程序非常有用。这些程序根据机器代码产生一种类似于汇编代码的格式。在 Linux系统中，使用命令 objdump -d main.o可以产生反汇编文件。示例如下图。</p>
<p><img src="/post/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E3%80%8B%E7%AC%AC3%E7%AB%A0%E7%AC%94%E8%AE%B0/3.1.png" alt="image-20201030224154512"></p>
<p>  在左边，我们看到按照前面给出的字节顺序排列的14个十六进制字节值，它们分成了若干组，每组有1~5个字节。每组都是一条指令，右边是等价的汇编语言</p>
<p>  其中一些关于机器代码和它的<strong>反汇编表示的特性值得注意</strong></p>
<ul>
<li><p>x86-64的指令长度从1到15个字节不等。常用的指令以及操作数较少的指令所需的字节数少，而那些不太常用或操作数较多的指令所需字节数较多</p>
</li>
<li><p>设计指令格式的方式是，从某个给定位置开始，可以将字节唯一地解码成机器指令。例如，只有指令 push%rbx是以字节值53开头的</p>
</li>
<li><p>反汇编器只是基于机器代码文件中的字节序列来确定汇编代码。它不需要访问该程序的源代码或汇编代码</p>
</li>
<li><p>反汇编器使用的指令命名规则与GCC生成的汇编代码使用的有些细微的差别。在我们的示例中，它省略了很多指令结尾的‘q’。这些后缀是大小指示符，在大多数情况中可以省略。相反，反汇编器给ca11和ret指令添加了‘q’后缀，同样，省略这些后缀也没有问题。</p>
</li>
</ul>
<h2 id="3-3-数据格式"><a href="#3-3-数据格式" class="headerlink" title="3.3 数据格式"></a>3.3 数据格式</h2><p>   Intel用术语“字（word）”表示16位数据类型。因此，称32位数为“双字（ double words）”，称64位数为“四字（ quad words）。下表给出了C语言基本数据类型对应的x86-64表示。</p>
<table>
<thead>
<tr>
<th align="center">C声明</th>
<th align="center">Intel数据类型</th>
<th align="center">汇编代码后缀</th>
<th align="center">大小（字节）</th>
</tr>
</thead>
<tbody><tr>
<td align="center">char</td>
<td align="center">字节</td>
<td align="center">b</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">short</td>
<td align="center">字</td>
<td align="center">w</td>
<td align="center">2</td>
</tr>
<tr>
<td align="center">int</td>
<td align="center">双字</td>
<td align="center">l</td>
<td align="center">4</td>
</tr>
<tr>
<td align="center">long</td>
<td align="center">四字</td>
<td align="center">q</td>
<td align="center">8</td>
</tr>
<tr>
<td align="center">char*</td>
<td align="center">四字</td>
<td align="center">q</td>
<td align="center">8</td>
</tr>
<tr>
<td align="center">float</td>
<td align="center"><strong>单精度</strong></td>
<td align="center">s</td>
<td align="center"><strong>4</strong></td>
</tr>
<tr>
<td align="center">double</td>
<td align="center"><strong>双精度</strong></td>
<td align="center">1</td>
<td align="center"><strong>8</strong></td>
</tr>
</tbody></table>
<h3 id="3-4-访问信息"><a href="#3-4-访问信息" class="headerlink" title="3.4 访问信息"></a>3.4 访问信息</h3><h4 id="操作数指示符"><a href="#操作数指示符" class="headerlink" title="操作数指示符"></a>操作数指示符</h4><h5 id="整数寄存器"><a href="#整数寄存器" class="headerlink" title="整数寄存器"></a>整数寄存器</h5><p>  不同位的寄存器名字不同，使用的时候要注意。</p>
<p><img src="/post/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E3%80%8B%E7%AC%AC3%E7%AB%A0%E7%AC%94%E8%AE%B0/3.2.png" alt="image-20201031150130488"></p>
<h5 id="三种类型的操作数"><a href="#三种类型的操作数" class="headerlink" title="三种类型的操作数"></a>三种类型的操作数</h5><p>  1.立即数,用来表示常数值，比如，<code>$0x1f</code> 。不同的指令允许的立即数值范围不同，汇编器会自动选择最紧凑的方式进行数值编码。</p>
<p>  2.寄存器，它表示某个寄存器的内容，16个寄存器的低位1字节、2字节、4字节或8字节中的一个作为操作数，这些字节数分别对应于8位、16位、32位或64位。在图3-3中，我们用符号<em>r**a</em></p>
<p>来表示任意寄存器a，用引用<em>R</em>[<em>r**a</em>]</p>
<p>来表示它的值，这是<strong>将寄存器集合看成一个数组R，用寄存器标识符作为索引</strong>。</p>
<p>  3.内存引用，它会根据计算出来的地址（通常称为有效地址）访问某个内存位置。因为将内存看成一个很大的字节数组，我们用符号<em>M**b</em>[<em>A<strong>d</strong>d**r</em>]</p>
<p>表示对存储在内存中从地址Addr开始的b个字节值的引用。为了简便，我们通常省去下标b。</p>
<h5 id="操作数的格式"><a href="#操作数的格式" class="headerlink" title="操作数的格式"></a>操作数的格式</h5><p>  看汇编指令的时候，对照下图可以读懂大部分的汇编代码。</p>
<p><img src="/post/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E3%80%8B%E7%AC%AC3%E7%AB%A0%E7%AC%94%E8%AE%B0/3.3.png" alt="image-20201031145813867"></p>
<h5 id="数据传送指令"><a href="#数据传送指令" class="headerlink" title="数据传送指令"></a>数据传送指令</h5><p><img src="/post/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E3%80%8B%E7%AC%AC3%E7%AB%A0%E7%AC%94%E8%AE%B0/3.4.png" alt="image-20201101214234883"></p>
<p>  不同后缀的指令主要区别在于它们操作的数据大小不同。</p>
<p>  源操作数：寄存器，内存</p>
<p>  目的操作数：寄存器，内存。</p>
<blockquote>
<p>注意：传送指令的两个操作数不能都指向内存位置。将一个值从一个内存位置复制到另一个内存位置需要两条指令—第一条指令将源值加载到寄存器中，第二条将该寄存器值写入目的位置。</p>
</blockquote>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">movl $0x4050,%eax         Immediate--Register,4 bytes p，1sp  move </span><br><span class="line">movw %bp,%sp              Register--Register, 2 bytes</span><br><span class="line">movb (%rdi. %rcx),%al     Memory--Register  1 bytes</span><br><span class="line">movb $-17,(%rsp)          Immediate--Memory 1 bytes</span><br><span class="line">movq %rax,-12(%rpb)       Register--Memory, 8 bytes</span><br></pre></td></tr></table></figure>
</blockquote>
<p>  将较小的源值复制到较大的目的时使用如下指令。</p>
<p><img src="/post/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E3%80%8B%E7%AC%AC3%E7%AB%A0%E7%AC%94%E8%AE%B0/3.5.png" alt="image-20201101215745466"></p>
<p><img src="/post/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E3%80%8B%E7%AC%AC3%E7%AB%A0%E7%AC%94%E8%AE%B0/3.6.png" alt="image-20201101215812134"></p>
<blockquote>
<p>举例</p>
<p><img src="/post/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E3%80%8B%E7%AC%AC3%E7%AB%A0%E7%AC%94%E8%AE%B0/3.7.png" alt="image-20201101220323188"></p>
</blockquote>
<p>  过程参数xp和y分别存储在寄存器%rdi和%rsi中（参数通过寄存器传递给函数）。</p>
<p>  第二行：<strong>指令movq</strong>从内存中读出xp，把它存放到寄存器**%rax**中（像x这样的局部变量通常是保存在寄存器中，而不是在内存中）。</p>
<p>  第三行：<strong>指令movq</strong>将y写入到寄存器**%rdi**中的xp指向的内存位置。</p>
<p>  第四行：<strong>指令ret</strong>用寄存器 <strong>%rax</strong>从这个函数返回一个值。</p>
<p>  总结：</p>
<p>  间接引用指针就是将该指针放在一个寄存器中，然后在内存引用中使用这个寄存器。</p>
<p>  像x这样的局部变量通常是保存在寄存器中，而不是内存中。访问寄存器比访问内存要快得多。</p>
<h5 id="压入和弹出栈数据"><a href="#压入和弹出栈数据" class="headerlink" title="压入和弹出栈数据"></a>压入和弹出栈数据</h5><p><img src="/post/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E3%80%8B%E7%AC%AC3%E7%AB%A0%E7%AC%94%E8%AE%B0/3.8.png" alt="image-20201101220629292"></p>
<p>  pushq指令的功能是把数据压入到栈上，而popq指令是弹出数据。这些指令都只有一个操作数——压入的数据源和弹出的数据目的。</p>
<blockquote>
<p>pushq %rbp等价于以下两条指令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">subq $8,%rsp             Decrement stack pointer</span><br><span class="line">movq %rbp,(%rsp)       Store %rbp on stack</span><br></pre></td></tr></table></figure>

<p>popq %rax等价于下面两条指令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mova (%rsp), %rax        Read %rax from stack </span><br><span class="line">addq $8,%rsp             Increment stack pointer</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="3-5-算数和逻辑操作"><a href="#3-5-算数和逻辑操作" class="headerlink" title="3.5 算数和逻辑操作"></a>3.5 算数和逻辑操作</h3><h5 id="加载有效地址"><a href="#加载有效地址" class="headerlink" title="加载有效地址"></a>加载有效地址</h5><p>  IA32指令集中有这样一条加载有效地址指令<code>leal</code>，用法为<code>leal S, D</code>，效果是将S的地址存入D，是mov指令的变形。可是这条指令往往用在计算乘法上，GCC编译器特别喜欢使用这个指令，比如下面的例子</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">leal (%eax, %eax, 2), %eax</span><br></pre></td></tr></table></figure>

<p>  实现的功能相当于<code>%eax = %eax * 3</code>。括号中是一种比例变址寻址，将第一个数加上第二个数和第三个数的乘积作为地址寻址，<code>leal</code>的效果使源操作数正好是寻址得到的地址，然后将其赋值给<code>%eax</code>寄存器。为什么用这种方式算乘法，而不是用乘法指令<code>imul</code>呢？</p>
<p>  这是因为Intel处理器有一个专门的地址运算单元，使得leal的执行不必经过ALU，而且只需要单个时钟周期。相比于<code>imul</code>来说要快得多。因此，对于大部分乘数为小常数的情况，编译器都会使用<code>leal</code>完成乘法操作。</p>
<h5 id="一元和二元操作"><a href="#一元和二元操作" class="headerlink" title="一元和二元操作"></a>一元和二元操作</h5><table>
<thead>
<tr>
<th>地址</th>
<th>值</th>
</tr>
</thead>
<tbody><tr>
<td>0x100</td>
<td>0xFF</td>
</tr>
<tr>
<td>0x108</td>
<td>0xAB</td>
</tr>
<tr>
<td>0x110</td>
<td>0x13</td>
</tr>
<tr>
<td>0x118</td>
<td>0x11</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>寄存器</th>
<th>值</th>
</tr>
</thead>
<tbody><tr>
<td>%rax</td>
<td>0x100</td>
</tr>
<tr>
<td>%rcx</td>
<td>0x1</td>
</tr>
<tr>
<td>%rdx</td>
<td>0x3</td>
</tr>
</tbody></table>
<p>  看个例子应该就明白这些指令的含义了，不知道指令意思的，可以看操作数的格式这一节中总结的常见汇编指令的格式。</p>
<table>
<thead>
<tr>
<th>指令</th>
<th>目的</th>
<th>值</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>addq %rcx,(%rax)</td>
<td>0x100</td>
<td>0x100</td>
<td>将rcx寄存器的值（0x1）加到%rax地址处（0xFF）</td>
</tr>
<tr>
<td>subq %rdx,8(%rax)</td>
<td>0x108</td>
<td>0xA8</td>
<td>从8(%rax)地址处取值（0XAB）并减去%rdx的值（0x3）</td>
</tr>
<tr>
<td>imulq $16,(%rax,%rdx,8)</td>
<td>0x118</td>
<td>0x110</td>
<td>（0x100+0x3 * 8） = 118.从118的地址取值并乘以10（16）结果为0x110</td>
</tr>
<tr>
<td>incq 16(%rax)</td>
<td>0x110</td>
<td>0x14</td>
<td>%rax + 16 = 0x100+10 = 0x110。从0x110取值得0x13，结果+1为0x14。</td>
</tr>
<tr>
<td>decq %rcx</td>
<td>%rcx</td>
<td>0x0</td>
<td>0x1-1</td>
</tr>
</tbody></table>
<h5 id="移位操作"><a href="#移位操作" class="headerlink" title="移位操作"></a>移位操作</h5><p>  左移指令：SAL,SHL</p>
<p>  算术右移指令：SAR(填上符号位)</p>
<p>  逻辑右移指令：SHR（填上0）</p>
<p>  移位操作的目的操作数是一个寄存器或是一个内存位置。169</p>
<p><img src="/post/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E3%80%8B%E7%AC%AC3%E7%AB%A0%E7%AC%94%E8%AE%B0/3.9.png" alt="image-20201101223636287"></p>
<p>  C语言对应的汇编代码</p>
<p><img src="/post/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E3%80%8B%E7%AC%AC3%E7%AB%A0%E7%AC%94%E8%AE%B0/3.10.png" alt="image-20201101223537078"></p>
<p><img src="/post/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E3%80%8B%E7%AC%AC3%E7%AB%A0%E7%AC%94%E8%AE%B0/3.11.png" alt="image-20201101223407147"></p>
<h2 id="3-6-控制"><a href="#3-6-控制" class="headerlink" title="3.6 控制"></a>3.6 控制</h2><h5 id="条件码"><a href="#条件码" class="headerlink" title="条件码"></a>条件码</h5><p><strong>条件码的定义</strong>：</p>
<p>  描述了最近的算术或逻辑操作的属性。可以检测这些寄存器来<strong>执行条件分支指令</strong>。</p>
<p><strong>常用的条件码</strong></p>
<p>  CF：进位标志。最近的操作使最高位产生了进位。可用来检查无符号操作的溢出。<br>  ZF：零标志。最近的操作得出的结果为0。<br>  SF：符号标志。最近的操作得到的结果为负数。<br>  OF：溢出标志。最近的操作导致一个补码溢出—正溢出或负溢出。</p>
<p><strong>改变条件码的指令</strong></p>
<p><img src="/post/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E3%80%8B%E7%AC%AC3%E7%AB%A0%E7%AC%94%E8%AE%B0/3.12.png" alt="image-20201104155658145"></p>
<p>  cmp指令根据两个操作数之差来设置条件码，常用来比较两个数，但是不会改变操作数。</p>
<p>  test指令用来测试这个数是正数还是负数，是零还是非零。两个操作数相同</p>
<blockquote>
<p>test %rax,%rax  //检查%rax是负数、零、还是正数（%rax &amp;&amp; %rax）</p>
<p>cmp %rax,%rdi //与sub指令类似，%rdi  -  %rax 。</p>
</blockquote>
<p><img src="/post/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E3%80%8B%E7%AC%AC3%E7%AB%A0%E7%AC%94%E8%AE%B0/3.13.png" alt="image-20201104160246288"></p>
<p>  上表中除了leap指令，其他指令都会改变条件码。</p>
<blockquote>
<p>ⅩOR，进位标志和溢出标志会设置成0.对于移位操作，进位标志将设置为最后一个被移出的位，而溢出标志设置为0。INC和DEC指令会设置溢出和零标志。</p>
</blockquote>
<h5 id="访问条件码"><a href="#访问条件码" class="headerlink" title="访问条件码"></a>访问条件码</h5><p><strong>访问条件码的三种方式</strong></p>
<p>  1.可以根据条件码的某种组合，将一个字节设置为0或者1。</p>
<p>  2.可以条件跳转到程序的某个其他的部分。</p>
<p>  3.可以有条件地传送数据。</p>
<p>  对于第一种情况，常使用set指令来设置，set指令如下图所示。</p>
<p><img src="/post/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E3%80%8B%E7%AC%AC3%E7%AB%A0%E7%AC%94%E8%AE%B0/3.14.png" alt="image-20201104164128434"></p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">计算a&lt;b的汇编代码</span><br><span class="line">int comp(data_t a,data_t b)</span><br><span class="line">a in %rdi,b in %rsi</span><br><span class="line">*/</span><br><span class="line">comp:</span><br><span class="line">cmpq %rsi,%rdi</span><br><span class="line">setl %al</span><br><span class="line">movzbl %al,%eax</span><br><span class="line">ret</span><br></pre></td></tr></table></figure>

<p>setl %al 当a&lt;b,设置%eax的低位为0或者1。</p>
</blockquote>
<h5 id="跳转指令"><a href="#跳转指令" class="headerlink" title="跳转指令"></a>跳转指令</h5><p><img src="/post/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E3%80%8B%E7%AC%AC3%E7%AB%A0%E7%AC%94%E8%AE%B0/3.15.png" alt="image-20201104164950004"></p>
<p>  上表中的有些指令是带有后缀的，表示条件跳转，下面解释下这些后缀，有助于记忆。</p>
<p>  e == equal，ne == not equal，s == signed，ns == not signed，g == greater，ge  == greater or equal，l == less,le == less or eauql,a == ahead，ae == ahead or equal,b == below,be == below or equal</p>
<p>  直接跳转</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmp .L1 <span class="comment">//直接给出标号，跳转到标号处</span></span><br></pre></td></tr></table></figure>

<p>  间接跳转</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jmp *%rax  <span class="comment">//用寄存器%rax中的值作为跳转目标</span></span><br><span class="line">jmp *(%rax) <span class="comment">//以%rax中的值作为读地址，从内存中读出跳转目标</span></span><br></pre></td></tr></table></figure>

<h5 id="跳转指令的编码"><a href="#跳转指令的编码" class="headerlink" title="跳转指令的编码"></a>跳转指令的编码</h5><p>  通过看跳转指令的编码格式理解下程序计数器PC是如何实现跳转的。</p>
<p>  汇编</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">movq %rdi, %rax </span><br><span class="line">jmp .L2</span><br><span class="line">.L3：</span><br><span class="line">sarq %rax </span><br><span class="line">.L2：</span><br><span class="line">testq %rax, %rax </span><br><span class="line">jg .L3</span><br><span class="line">rep;ret</span><br></pre></td></tr></table></figure>

<p>  反汇编</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>:<span class="number">48</span> <span class="number">89</span> f8      mov %rdi,%raxrdi, </span><br><span class="line"><span class="number">3</span>:eb <span class="number">03</span>         jmp <span class="number">8</span> &lt;loop+<span class="number">0x8</span>&gt;</span><br><span class="line"><span class="number">5</span>:<span class="number">48</span> d1 f8      sar %rax</span><br><span class="line"><span class="number">8</span>:<span class="number">48</span> <span class="number">85</span> c0      test %rax %rax</span><br><span class="line">b:<span class="number">71</span> f8         jg <span class="number">5</span>&lt;loop+<span class="number">0x5</span>&gt;</span><br><span class="line">d: f3 C3        repz rete</span><br></pre></td></tr></table></figure>

<p>  右边反汇编器产生的注释中，第2行中跳转指令的跳转目标指明为0x8，第5行中跳转指令的跳转目标是0x5（反汇编器以十六进制格式给出所有的数字）。不过，观察指令的宇节编码，会看到第一条跳转指令的目标编码（在第二个字节中）为0x03.把它加上0×5，也就是下一条指令的地址，就得到跳转目标地址0x8，也就是第4行指令的地址。</p>
<p>  类似，第二个跳转指令的目标用单字节、补码表示编码为0xf8（十进制-8）。将这个数加上0xa（十进制13），即第6行指令的地址，我们得到0x5，即第3行指令的地址。</p>
<p>  这些例子说明，当执行PC相对寻址时，<strong>程序计数器的值是跳转指令后面的那条指令的地址，而不是跳转指令本身的地址</strong>。</p>
<h5 id="条件控制实现条件分支"><a href="#条件控制实现条件分支" class="headerlink" title="条件控制实现条件分支"></a>条件控制实现条件分支</h5><p><img src="/post/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E3%80%8B%E7%AC%AC3%E7%AB%A0%E7%AC%94%E8%AE%B0/3.16.png" alt="image-20201104174115100"></p>
<p>  上图分别给出了C语言，goto表示，汇编语言的三种形式。这里使用goto语句，是为了构造描述汇编代码程序控制流的C程序。</p>
<p>  汇编代码的实现（图3-16c）首先比较了两个操作数（第2行），设置条件码。如果比较的结果表明x大于或者等于y，那么它就会跳转到第8行，增加全局变量 ge_cnt，计算x-y作为返回值并返回。由此我们可以看到 absdiff_se对应汇编代码的控制流非常类似于gotodiff_  se的goto代码。</p>
<p>  C语言中的if-else通用模版如下：</p>
<p><img src="/post/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E3%80%8B%E7%AC%AC3%E7%AB%A0%E7%AC%94%E8%AE%B0/3.17.png" alt="image-20201104175413267"></p>
<p>  对应的汇编代码如下：</p>
<p><img src="/post/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E3%80%8B%E7%AC%AC3%E7%AB%A0%E7%AC%94%E8%AE%B0/3.18.png" alt="image-20201104175428373"></p>
<h5 id="条件传送实现条件分支"><a href="#条件传送实现条件分支" class="headerlink" title="条件传送实现条件分支"></a>条件传送实现条件分支</h5><p><img src="/post/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E3%80%8B%E7%AC%AC3%E7%AB%A0%E7%AC%94%E8%AE%B0/3.19.png" alt="image-20201104174629197"></p>
<p>  GCC为该函数产生的汇编代码如图3-17c所示，它与图3-17b中所示的C函数cmovdiff有相似的形式。研究这个C版本，<strong>我们可以看到它既计算了y-x，也计算了x-y，分别命名为rval和eval</strong>。然后它再测试x是否大于等于y，如果是，就在函数返回rval前，将eval复制到rval中。图3-17c中的汇编代码有相同的逻辑。关键就在于汇编代码的那条 <strong>cmovge指令</strong>（第7行）实现了 cmovdiff的条件赋值（第8行）。<strong>只有当第6行的cmpq指令表明一个值大于等于另一个值（正如后缀ge表明的那样）时，才会把数据源寄存器传送到目的</strong>。</p>
<p>  条件控制的汇编模版如下：</p>
<p><img src="/post/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E3%80%8B%E7%AC%AC3%E7%AB%A0%E7%AC%94%E8%AE%B0/3.20.png" alt="image-20201104175602353"></p>
<p>  实际上，基于条件数据传送的代码会比基于条件控制转移的代码性能要好。主要原因是处理器通过使用流水线来获得高性能，处理器采用非常精密的<strong>分支预测逻辑</strong>来猜测每条跳转指令是否会执行。只要它的猜测还比较可靠（现代微处理器设计试图达到90%以上的成功率），指令流水线中就会充满着指令。另一方面，错误预测一个跳转，要求处理器丢掉它为该跳转指令后所有指令已做的工作，然后再开始用从正确位置处起始的指令去填充流水线。这样一个错误预测会招致很严重的惩罚，<strong>浪费大约15~30个时钟周期，导致程序性能严重下降</strong>。</p>
<p>  使用条件传送也不总是会提高代码的效率。例如，如果 then expr或者 else expr的求值<strong>需要大量的计算</strong>，那么当相对应的条件不满足时，这些工作就白费了。编译器必须<strong>考虑浪费的计算和由于分支预测错误所造成的性能处罚之间的相对性能</strong>。说实话，编译器井不具有足够的信息来做出可靠的决定；例如，它们不知道分支会多好地遵循可预测的模式。我们对GCC的实验表明，只有当两个表达式都很容易计算时，例如表达式分别都只是条加法指令，它才会使用条件传送。根据我们的经验，即使许多分支预测错误的开销会超过更复杂的计算，GCC还是会使用条件控制转移。</p>
<p>  所以，总的来说，条件数据传送提供了一种用条件控制转移来实现条件操作的替代策略。它们只能用于非常受限制的情况，但是这些情况还是相当常见的，而且与现代处理器的运行方式更契合。</p>
<h5 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h5><p>  将循环翻译成汇编主要有两种方法，第一种我们称为<strong>跳转到中间</strong>，它执行一个<strong>无条件跳转</strong>跳到循环结尾处的测试，以此来执行初始的测试。第二种方法叫<strong>guarded-do</strong>，首先用条件分支，如果初始条件不成立就跳过循环，把代码变换为do-whie循环。当使用较髙优化等级编译时，例如使用命令行选项-O1，GCC会采用这种策略。</p>
<p><strong>跳转到中间</strong></p>
<p>  如下图所示为while循环写的计算阶乘的代码。可以看到编译器使用了跳转到中间的翻译方法，在第3行用jmp跳转到以标号L5开始的测试，如果n满足要求就执行循环，否则就退出。</p>
<p><img src="/post/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E3%80%8B%E7%AC%AC3%E7%AB%A0%E7%AC%94%E8%AE%B0/3.21.png" alt="image-20201106155420381"></p>
<p><strong>guarded-do</strong></p>
<p>  下图为使用第二种方法编译的汇编代码，编译时是用的是-O1，GCC就会采用这种方式编译循环。</p>
<p><img src="/post/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E3%80%8B%E7%AC%AC3%E7%AB%A0%E7%AC%94%E8%AE%B0/3.22.png" alt="image-20201106160031027"></p>
<p>  上面介绍的是while循环和do-while循环的两种编译模式，<strong>根据GCC不同的优化结果会得到不同的汇编代码</strong>。实际上，for循环产生的汇编代码也是以上两种汇编代码中的一种。for循环的通用形式如下所示。</p>
<p><img src="/post/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E3%80%8B%E7%AC%AC3%E7%AB%A0%E7%AC%94%E8%AE%B0/3.23.png" alt="image-20201106162441921"></p>
<p>  选择跳转到中间策略会得到如下goto代码：</p>
<p><img src="/post/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E3%80%8B%E7%AC%AC3%E7%AB%A0%E7%AC%94%E8%AE%B0/3.24.png" alt="image-20201106162556429"></p>
<p>  guarded-do策略会得到如下goto代码：</p>
<p><img src="/post/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E3%80%8B%E7%AC%AC3%E7%AB%A0%E7%AC%94%E8%AE%B0/3.25.png" alt="image-20201106162625631"></p>
<h5 id="suitch语句"><a href="#suitch语句" class="headerlink" title="suitch语句"></a>suitch语句</h5><p>  switch语句可以根据一个整数索引值进行<strong>多重分支</strong>。它们不仅提高了C代码的可读性而且通过使用<strong>跳转表</strong>这种数据结构使得实现更加高效。跳转表是一个<strong>数组</strong>，表项i是一个代码段的地址，这个代码段实现当开关索引值等于i时程序应该采取的动作。</p>
<p>  程序代码用开关索引值来执行一个跳转表内的<strong>数组引用，确定跳转指令的目标</strong>。和使用组很长的if-else语句相比，<strong>使用跳转表的优点是执行开关语句的时间与开关情况的数量无关</strong>。GCC根据开关情况的数量和开关情况值的稀疏程度来翻译开关语句。当开关情况数量比较多（例如4个以上），并且值的范围跨度比较小时，就会使用跳转表。</p>
<p><img src="/post/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E3%80%8B%E7%AC%AC3%E7%AB%A0%E7%AC%94%E8%AE%B0/3.26.png" alt="image-20201106171009414"></p>
<p>  原始的C代码有针对值100、102104和106的情况，但是开关变量n可以是任意整数。编译器首先将<strong>n减去100</strong>，把<strong>取值范围移到0和6之间</strong>，创建一个新的程序变量，在我们的C版本中称为 index。补码表示的负数会映射成无符号表示的大正数，利用这一事实，将 index看作无符号值，从而进一步简化了分支的可能性。因此可以通过测试 <strong>index是否大于6来判定index是否在0~6的范围之外</strong>。在C和汇编代码中，根据 index的值，有五个不同的跳转位置：loc_A（.L3）,loc_B（.L5），loc_C（.L6），loc_D（.L7）和  loc_def（.L8），最后一个是默认的目的地址。每个标号都标识一个实现某个情况分支的代码块。在C和汇编代码中，<strong>程序都是将 index和6做比较，如果大于6就跳转到默认的代码处</strong>。</p>
<p><img src="/post/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E3%80%8B%E7%AC%AC3%E7%AB%A0%E7%AC%94%E8%AE%B0/3.27.png" alt="image-20201106172403510"></p>
<p>  执行 switch语句的关键步骤是<strong>通过跳转表来访问代码位置</strong>。在C代码中是第16行一条goto语句引用了跳转表jt。GCC支持计算goto，是对C语言的扩展。在我们的汇编代码版本中，类似的操作是在第5行，jmp指令的操作数有前缀‘ * ’，表明这是一个<strong>间接跳转，操作数指定一个内存位置</strong>，索引由寄存器%rsi给出，这个寄存器保存着 index的值。</p>
<p>  C代码将跳转表声明为一个有7个元素的数组，每个元素都是一个指向代码位置的指针。这些元素跨越 index的值0 ~ 6，对应于n的值100~106。可以观察到，跳转表对重复情况的处理就是<strong>简单地对表项4和6用同样的代码标号（loc_D）</strong>，而对于缺失的情况的处理就是<strong>对表项1和5使用默认情况的标号（loc_def）</strong>。</p>
<p>  在汇编代码中，跳转表声明为如下形式</p>
<p><img src="/post/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E3%80%8B%E7%AC%AC3%E7%AB%A0%E7%AC%94%E8%AE%B0/3.28.png" alt="image-20201106172457352"></p>
<p>  （.rodata段的详细解释在我总结的嵌入式软件开发笔试面试知识点中有详细介绍）</p>
<p><strong>已知switch汇编代码，如何利用汇编语言和跳转表的结构推断出switch的C语言结构？</strong></p>
<p>  关于C语言的switch语句，需要重点确定的有跳转表的大小，跳转范围，那些case是缺失的，那些是重复的。下面我们一 一确定。</p>
<p>  这些表声明中，从图3-23的汇编第1行可以知道，n的起始计数为100。由第二行可以知道，变量和6进行比较，说明跳转表索引偏移范围为0 ~ 6，对应为100 ~106。从.quad .L3开始，由上到下，依次编号为0,1,2,3,4,5,6。其中由图3-23的ja  .L8可知，大于6时就跳转到.L8，那么跳转表中编号为1和5的都是跳转的默认位置。因此，编号为1和5的为缺失的情况,即没有101和105的选项。而编号为4和6的都跳转到了.L7,说明两者是对应于100+4=104,100+6=106。剩下的情况0,2,3依次编号为100,102,103。至此我们就得出了switch的编号情况，一共有6项，100,102,103,104,106，default。剩下的关于每种case的C语言内容就可以根据汇编代码写出来了。</p>
<h4 id="3-7-过程"><a href="#3-7-过程" class="headerlink" title="3.7 过程"></a>3.7 过程</h4><h5 id="运行时栈"><a href="#运行时栈" class="headerlink" title="运行时栈"></a>运行时栈</h5><p>  C语言过程调用机制的一个关键特性（大多数其他语言也是如此）在于使用了<strong>栈数据结构提供的后进先出</strong>的内存管理原则。假如在过程P调用过程Q时，可以看到当Q在执行时，P以及所有在向上追溯到P的调用链中的过程，都是暂时<strong>被挂起</strong>的。当Q运行时，它只需要为局部变量<strong>分配新的存储空间</strong>，或者设置到另一个过程的调用。另一方面，当Q返回时，任何它所分配的<strong>局部存储空间都可以被释放</strong>。因此，<strong>程序可以用栈来管理它的过程所需要的存储空间，栈和程序寄存器存放着传递控制和数据、分配内存所需要的信息</strong>。当P调用Q时，控制和数据信息添加到栈尾。当P返回时，这些信息会释放掉。</p>
<p><img src="/post/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E3%80%8B%E7%AC%AC3%E7%AB%A0%E7%AC%94%E8%AE%B0/3.29.png" alt="image-20201107144949376"></p>
<p>  x86-64的栈向低地址方向增长，而栈指针号%rsp指向栈顶元素。可以用 pushq和popq指令将数据存人栈中或是从栈中取出。<strong>将栈指针减小一个适当的量可以为没有指定初始值的数据在栈上分配空间。类似地，可以通过增加栈指针来释放空间。</strong></p>
<p>  过程P可以传递最多6个整数值（也就是指针和整数），但是如果Q需要更多的参数，P可以在调用Q之前在自己的<strong>栈帧（也就是内存）</strong>里存储好这些参数。</p>
<h5 id="转移控制"><a href="#转移控制" class="headerlink" title="转移控制"></a>转移控制</h5><p>  将控制从函数转移到函数Q只需要简单地把<strong>程序计数器（PC）设置为Q的代码的起始位置</strong>。不过，当稍后从Q返回的时候，处理器必须记录好它需要继续P的执行的代码位置。在x86-64机器中，这个信息是用指令call Q调用过程Q来记录的。该指令会把<strong>地址A压入栈中</strong>，并<strong>将PC设置为Q的起始地址</strong>。压入的地址A被称为<strong>返回地址</strong>，是紧跟在call指令后面的那条指令的地址。对应的指令ret会从栈中弹出地址A，并把PC设置为A。</p>
<p><img src="/post/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E3%80%8B%E7%AC%AC3%E7%AB%A0%E7%AC%94%E8%AE%B0/3.30.png" alt="image-20201107170128713"></p>
<p>  下面看个例子</p>
<p><img src="/post/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E3%80%8B%E7%AC%AC3%E7%AB%A0%E7%AC%94%E8%AE%B0/3.31.png" alt="image-20201107170248280"></p>
<p><img src="/post/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E3%80%8B%E7%AC%AC3%E7%AB%A0%E7%AC%94%E8%AE%B0/3.32.png" alt="image-20201107170636553"></p>
<p>  main调用top（100），然后top调用leaf（95）。函数leaf向top返回97，然后top向main返回194.前面三列描述了被执行的指令，包括指令标号、地址和指令类型。后面四列给出了在该指令执行前程序的状态，包括寄存器%rdi、%rax和%rsp的内容，以及位于栈顶的值。</p>
<p>  leaf的指令L1将%rax设置为97，也就是要返回的值。然后指令L2返回，它从栈中弹出0×400054e。通过将PC设置为这个弹出的值，控制转移回top的T3指令。程序成功完成对leaf的调用，返回到top。</p>
<p>  指令T3将%rax设置为194，也就是要从top返回的值。然后指令T4返回，它从栈中弹出0×4000560，因此将PC设置为main的M2指令。程序成功完成对top的调用，返回到main。可以看到，此时栈指针也恢复成了0x7fffffffe820，即调用top之前的值。</p>
<p>  <strong>这种把返回地址压入栈的简单的机制能够让函数在稍后返回到程序中正确的点</strong>。C语言标准的调用/返回机制刚好与栈提供的后进先出的内存管理方法吻合。</p>
<h5 id="数据传送"><a href="#数据传送" class="headerlink" title="数据传送"></a>数据传送</h5><p>  X86-64中，可以通过寄存器来传递最多6个参数。寄存器的使用是有特殊顺序的，如下表所示，会根据参数的顺序为其分配寄存器。</p>
<p><img src="/post/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E3%80%8B%E7%AC%AC3%E7%AB%A0%E7%AC%94%E8%AE%B0/3.33.png" alt="image-20201107150424194"></p>
<p>  当传递参数超过6个时，会把大于6个的部分放在栈上。</p>
<p>  如下图所示的部分，红框内的参数就是存储在栈上的。</p>
<p><img src="/post/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E3%80%8B%E7%AC%AC3%E7%AB%A0%E7%AC%94%E8%AE%B0/3.34.png" alt="image-20201107152154583"></p>
<h5 id="栈上的局部存储"><a href="#栈上的局部存储" class="headerlink" title="栈上的局部存储"></a>栈上的局部存储</h5><p>  通常来说，不需要超出寄存器大小的本地存储区域。不过有些时候，<strong>局部数据必须存放在内存中</strong>，常见的情况包括：1.寄存器不足够存放所有的本地数据。<br> 2.对一个局部变量使用地址运算符‘&amp;‘，因此必须能够为它产生一个地址。3.某些局部变量是数组或结构，因此必须能够通过数组或结构引用被访问到。</p>
<p>  下面看一个例子。</p>
<p><img src="/post/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E3%80%8B%E7%AC%AC3%E7%AB%A0%E7%AC%94%E8%AE%B0/3.35.png" alt="image-20201107153947303"></p>
<p><img src="/post/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E3%80%8B%E7%AC%AC3%E7%AB%A0%E7%AC%94%E8%AE%B0/3.36.png" alt="image-20201107154242368"></p>
<p>  第二行的subq指令将栈指针减去32，实际上就是分配了32个字节的内存空间。在栈指针的基础上，分别+24,+20,+18,+17，用来存放1,2,3,4的值。在第7行中，使用leaq生成到17（%rsp）的指针并赋值给%rax。接着在栈指针基础上+8和+16的位置存放参数7和参数8。而参数1-参数6分别放在6个寄存器中。栈帧的结构如下图所示。</p>
<p><img src="/post/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E3%80%8B%E7%AC%AC3%E7%AB%A0%E7%AC%94%E8%AE%B0/3.37.png" alt="image-20201107155835033"></p>
<p>  上述汇编中第2-15行都是在为调用proc做准备（为局部变量和函数建立栈帧，将函数加载到寄存器）。当准备工作完成后，就会开始执行proc的代码。当程序返回call_proc时，代码会取出4个局部变量（第17~20行），并执行最终的计算。在程序结束前，把栈指针加32，释放这个栈帧。</p>
<h5 id="寄存器中的局部存储"><a href="#寄存器中的局部存储" class="headerlink" title="寄存器中的局部存储"></a>寄存器中的局部存储</h5><p>  寄存器组是唯一被所有过程共享的资源。因此，在某些调用过程中，我们要不同过程调用的寄存器不能相互影响。</p>
<p>  根据惯例，寄存器%rbx、%rbp和%r12~%r15被划分为<strong>被调用者保存寄存器</strong>。当过程P调用过程Q时，Q必须保存这些寄存器的值，<strong>保证它们的值在Q返回到P时与Q被调用时是一样的</strong>。过程Q保存一个寄存器的值不变，要么就是根本不去改变它，要么就是把原始值压入栈中。有了这条惯例，P的代码就能安全地把值存在被调用者保存寄存器中（当然，要先把之前的值保存到栈上），调用Q，然后继续使用寄存器中的值。</p>
<p>  下面看个例子。</p>
<p><img src="/post/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E3%80%8B%E7%AC%AC3%E7%AB%A0%E7%AC%94%E8%AE%B0/3.38.png" alt="image-20201107160726777"></p>
<p>  可以看到GCC生成的代码使用了两个<strong>被调用者保存寄存器</strong>：%rbp保存x和%rbx保存计算出来的Q（y）的值。在函数的开头，把这两个寄存器的值保存到栈中（第2<del>3行）。在第一次调用Q之前，把参数ⅹ复制到%rbp（第5行）。在第二次调用Q之前，把这次调用的结果复制到%rbx （第8行）。在函数的结尾，（第13</del>14行），把它们从栈中弹出，恢复这两个被调用者保存寄器的值。注意它们的弹压入顺序，说明了栈的后进先出规则。</p>
<h5 id="递归过程"><a href="#递归过程" class="headerlink" title="递归过程"></a>递归过程</h5><p>  根据之前的内容可以知道，多个过程调用在栈中都有自己的私有空间，多个未完成调用的局部变量不会相互影响，递归本质上也是多个过程的相互调用。如下所示为一个计算阶乘的递归调用。</p>
<p><img src="/post/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E3%80%8B%E7%AC%AC3%E7%AB%A0%E7%AC%94%E8%AE%B0/3.39.png" alt="image-20201107163433595"></p>
<p>  上图给出了递归的阶乘函数的C代码和生成的汇编代码。可以看到汇编代码使用寄存器%rbx来保存参数n，先把已有的值保存在栈上（第2行），随后在返回前恢复该值（第11行）。根据栈的使用特性和寄存器保存规则，可以保证当递归调用 refact（n-1）返回时（第9行），<strong>（1）该次调用的结果会保存在寄存器号%rax中，（2）参数n的值仍然在寄存器各%rbx中</strong>。把这两个值相乘就能得到期望的结果。</p>
<h2 id="3-8数组分配和访问"><a href="#3-8数组分配和访问" class="headerlink" title="3.8数组分配和访问"></a>3.8数组分配和访问</h2><h5 id="基本原则"><a href="#基本原则" class="headerlink" title="基本原则"></a>基本原则</h5><p>  在机器代码级是没有数组这一更高级的概念的,只是你将其视为字节的集合,这些字节的集合是在连续位置上存储的,结构也是如此，它就是作为字节集合来分配的,然后，C 编译器的工作就是生成适当的代码来分配该内存,从而当你去引用结构或数组的某个元素时，去获取正确的值。</p>
<p>  数据类型T和整型常数N，声明一个数组T A[N]。起始位置表示为<em>X**A</em></p>
<p>.这个声明有两个效果。首先，它在内存中分配一个<em>L</em>∙<em>N</em>字节的连续区域，这里L是数据类型T的大小（单位为字节）。其次，它引入了标识符A，可以用来作A为指向数组开头的指针，这个指针的值就是<em>X**A</em>。可以用0~N-1的整数索引来访问该数组元素。数组元素i会被存放在地址为<em>X**A</em>+<em>L</em>∙<em>i</em></p>
<p>的地方。</p>
<blockquote>
<p>char A[12];</p>
<p>char *B[8];</p>
<p>char C[6];</p>
<p>char *D[5];</p>
<table>
<thead>
<tr>
<th align="center">数组</th>
<th align="center">元素大小</th>
<th align="center">总的大小</th>
<th align="center">起始地址</th>
<th align="center">元素i</th>
</tr>
</thead>
<tbody><tr>
<td align="center">A</td>
<td align="center">1</td>
<td align="center">12</td>
<td align="center"><em>X**A</em></td>
<td align="center"></td>
</tr>
</tbody></table>
</blockquote>
<table>
<thead>
<tr>
<th></th>
<th><em>X**A</em>+<em>i</em></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>B</td>
<td>8</td>
<td>64</td>
<td><em>X**B</em></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th></th>
<th><em>X**B</em>+8<em>i</em></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>C</td>
<td>4</td>
<td>24</td>
<td><em>X**C</em></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th></th>
<th><em>X**C</em>+4<em>i</em></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>D</td>
<td>8</td>
<td>40</td>
<td><em>X**D</em></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th></th>
<th><em>X**D</em>+8<em>i</em></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<blockquote>
</blockquote>
<h5 id="指针运算"><a href="#指针运算" class="headerlink" title="指针运算"></a>指针运算</h5><p>  假设整型数组E的起始地址和整数索引i分别存放在寄存器是%rdx和%rcx中。下面是一些与E有关的表达式。我们还给出了每个表达式的汇编代码实现，结果存放在寄存器号%eax（如果是数据）或寄存器号%rax（如果是指针）中。</p>
<p><img src="/post/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E3%80%8B%E7%AC%AC3%E7%AB%A0%E7%AC%94%E8%AE%B0/6014302c6ca4a998546deba9bfb7d21f.png" alt="image-20201108173123826"></p>
<h5 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h5><p>  对于一个声明为T D[R] [C]的二维数组来说，数组D[i] [j]的内存地址为<em>X**D</em>+<em>L</em>(<em>C</em>∙<em>i</em>+<em>j</em>)</p>
<p>。</p>
<p>  这里，L是数据类型T以字节为单位的大小。假设<em>X**A</em></p>
<p>、i和j分别在寄存器%rdi、%rsi和%rdx中。然后，可以用下面的代码将数组元素A[i] [j]复制到寄存器%eax中:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/*A in %rdi, i in %rsi, and j in %rdx*/ </span><br><span class="line">leaq (%rsi,%rsi,2), %rax //Compute 3i</span><br><span class="line">leaq (%rdi,%rax,4)，%rax //Compute XA+ 12i </span><br><span class="line">movl (7rax, rdx, 4)， %eax //Read from M[XA+ 12i+4j]</span><br></pre></td></tr></table></figure>



<h2 id="3-9-异质的数据结构"><a href="#3-9-异质的数据结构" class="headerlink" title="3.9 异质的数据结构"></a>3.9 异质的数据结构</h2><h5 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h5><p>  C语言的 struct声明创建一个数据类型，将可能<strong>不同类型的对象</strong>聚合到一个对象中。结构的所有组成部分都存放在内存中一段连续的区域内，而指向结构的指针就是结构第个字节的地址。编译器维护关于每个结构类型的信息，指示每个字段（ field）的字节偏移。它以这些偏移作为内存引用指令中的位移，从而产生对结构元素的引用。</p>
<p>  结构体在内存中是以偏移的方式存储的，具体可以看这个文章。<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_16933601/article/details/108576447">Linux内核中container_of宏的详细解释</a>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rec</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">int</span> j;</span><br><span class="line">	<span class="keyword">int</span> a[<span class="number">2</span>];</span><br><span class="line">	<span class="keyword">int</span> *p;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>  这个结构包括4个字段：两个4字节int、一个由两个类型为int的元素组成的数组和一个8字节整型指针，总共是24个字节。</p>
<p><img src="/post/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E3%80%8B%E7%AC%AC3%E7%AB%A0%E7%AC%94%E8%AE%B0/8aeb1adc70544c510f9c12d9feb09264.png" alt="image-20201109153549034"></p>
<p>  看汇编代码也可以看出，结构体成员的访问是基地址加上偏移地址的方式。例如，假设 struct rec*类型的变量r放在寄存器%rdi中。那么下面的代码将元素r-&gt;i复制到元素r-&gt;j：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/*Registers:r in %rdi,i %rsi */</span><br><span class="line">movl (%rdi), %eax //Get r-&gt;i </span><br><span class="line">movl %eax, 4(%rdi) //Store in r-27</span><br><span class="line">leaq  8(%rdi,%rsi,4),//%rax 得到一个指针，8+4*%rsi,&amp;(r-&gt;a[i])</span><br></pre></td></tr></table></figure>

<h5 id="数据对齐"><a href="#数据对齐" class="headerlink" title="数据对齐"></a>数据对齐</h5><p>  关于字节对齐的相关内容见我整理的《嵌入式软件笔试面试知识点总结》里面详细介绍了字节对齐的相关内容。</p>
<h2 id="3-10-在机器级程序中将控制和程序结合起来"><a href="#3-10-在机器级程序中将控制和程序结合起来" class="headerlink" title="3.10 在机器级程序中将控制和程序结合起来"></a>3.10 在机器级程序中将控制和程序结合起来</h2><h5 id="理解指针"><a href="#理解指针" class="headerlink" title="理解指针"></a>理解指针</h5><p>  关于指针的几点说明：</p>
<p>  1.每个指针都对应一个类型</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *ip;<span class="comment">//ip为一个指向int类型对象的指针</span></span><br><span class="line"><span class="keyword">char</span> **cpp;<span class="comment">//cpp为指向指针的指针，即cpp指向的本身就是一个指向char类型对象的指针</span></span><br><span class="line"><span class="keyword">void</span> *p;<span class="comment">//p为通用指针，malloc的返回值为通用指针，通过强制类型转换可以转换成我们需要的指针类型</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>  2.每个指针都有一个值。这个值可以是某个指定类型的对象的地址，也可以是一个特殊的NULL（0）。</p>
<p>  3.指针用&amp;运算符创建。在汇编代码中，用leaq指令计算内存引用的地址。</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> *p = &amp;i;<span class="comment">//取i的地址赋值给p指针</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>  4.* 操作符用于间接引用指针。引用的结果是一个具体的数值，它的类型与该指针的类型一致。</p>
<p>  5.数组与指针紧密联系，但是又有所区别。</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>] =&#123;<span class="number">0</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>一个数组的名字可以像一个指针变量一样引用（但是不能修改）。数组引用（例如a[5]与指针运算和间接引用（例如*（a+5））有一样的效果。</p>
<p>数组引用和指针运算都需要用对象大小对偏移量进行<strong>伸缩</strong>。当我们写表达式a+i，这里指针p的值为a，得到的地址计算为a+L * i，这里L是与a相关联的数据类型的大小。</p>
<p>数组名<strong>对应</strong>的是一块内存地址，不能修改。指针<strong>指向</strong>的是任意一块内存，其值可以随意修改。</p>
</blockquote>
<p>  6.将指针从一种类型强制转換成另一种类型，<strong>只改变它的类型，而不改变它的值</strong>。强制类型转换的一个效果是<strong>改变指针运算的伸缩</strong>。例如，如果a是一个char * 类型的指针，它的值为a，a+7结果为a+7 * 1,而表达式（int* ）p+7结果为p+4 * 7。</p>
<h5 id="内存越界引用"><a href="#内存越界引用" class="headerlink" title="内存越界引用"></a>内存越界引用</h5><p>  C对于数组引用不进行任何边界检查，而且<strong>局部变量和状态信息</strong>（例如保存的寄存器值和返回地址）都存放在栈中。这两种情况结合到一起就能导致严重的程序错误，对越界的数组元素的写操作会<strong>破坏存储在栈中的状态信息</strong>。当程序使用这个被破坏的状态，就会出现很严重的错误，一种特别常见的状态破坏称为缓冲区溢出（ buffer overflow）。</p>
<p><img src="/post/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E3%80%8B%E7%AC%AC3%E7%AB%A0%E7%AC%94%E8%AE%B0/529c2f38d4fd25856f828cc09f02760c.png" alt="image-20201109201730652"></p>
<p><img src="/post/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E3%80%8B%E7%AC%AC3%E7%AB%A0%E7%AC%94%E8%AE%B0/d9291f28812b71aedfd466806cea181a.png" alt="image-20201109201936732"></p>
<p>  上述C代码，buf只分配了8个字节的大小，任何超过7字节的都会使的数组越界。</p>
<p>  输入不同数量的字符串会发生不同的错误，具体可以参考下图。</p>
<p><img src="/post/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E3%80%8B%E7%AC%AC3%E7%AB%A0%E7%AC%94%E8%AE%B0/b50d94d89e186838d37ee9e342e376de.png" alt="image-20201109202120957"></p>
<p>  echo函数的栈分布如下图所示。</p>
<p><img src="/post/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E3%80%8B%E7%AC%AC3%E7%AB%A0%E7%AC%94%E8%AE%B0/850fa8db462b3ed22eb5ac768fe81b98.png" alt="image-20201109202614633"></p>
<p>  字符串到23个字符之前都没有严重的后果，但是超过以后，返回指针的值以及更多可能的保存状态会被破坏。如果存储的返回地址的值被破坏了，那么ret指令（第8行）会导致程序跳转到一个<strong>完全意想不到的位置</strong>。如果只看C代码，根本就不可能看出会有上面这些行为。只有通过研究机器代码级别旳程序才能理解像gets这样的函数进行的内存越界写的影响。</p>
<h2 id="3-11浮点代码"><a href="#3-11浮点代码" class="headerlink" title="3.11浮点代码"></a>3.11浮点代码</h2><p>  计算机中的浮点数可以说是”另类”的存在，每次提到数据相关的内容时，浮点数总是会被单独拿出来说。同样，在汇编中浮点数也是和其他类型的数据有所差别的，我们需要<strong>考虑以下几个方面</strong>：1.如何存储和访问浮点数值。通常是通过某种寄存器方式来完成2.对浮点数据操作的指令3.向函数传递浮点数参数和从函数返回浮点数结果的规则。4.函数调用过程中保存寄存器的规则—例如，一些寄存器被指定为调用者保存，而其他的被指定为被调用者保存。</p>
<p>  X86-64浮点数是基于SSE或AVX的，包括传递过程参数和返回值的规则。在这里，我们讲解的是基于AVX2。在利用GCC进行编译时，加上-mavx2，GCC会生成AVX2代码。</p>
<p>  如下图所示，AVX浮点体系结构允许数据存储在16个YMM寄存器中，它们的名字为%ymm0<del>%ymm15。每个YMM寄存器都是256位（32字节）。当对标量数据操作时,这些寄存器只保存浮点数，而且只使用低32位（对于float）或64位（对于 double）。汇编代码用寄存器的 SSE  XMM寄存器名字%xmm0</del>%xmm15来引用它们，每个XMM寄存器都是对应的YMM寄存器的低128位（16字节）。</p>
<p><img src="/post/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E3%80%8B%E7%AC%AC3%E7%AB%A0%E7%AC%94%E8%AE%B0/6861bf8fb1eb47a6bd7cd3a7f9be33c4.png" alt="image-20201110155725299"></p>
<p>   其实浮点数的汇编指令和整数的指令都是差不多的，不需要都记住，用到的时候再查询就可以了。</p>
<h5 id="数据传送指令-1"><a href="#数据传送指令-1" class="headerlink" title="数据传送指令"></a>数据传送指令</h5><p><img src="/post/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E3%80%8B%E7%AC%AC3%E7%AB%A0%E7%AC%94%E8%AE%B0/e95b5aa82e8cb2dbbee2887045f9c7bd.png" alt="image-20201110155810267"></p>
<h5 id="双操作数浮点转换指令"><a href="#双操作数浮点转换指令" class="headerlink" title="双操作数浮点转换指令"></a>双操作数浮点转换指令</h5><p><img src="/post/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E3%80%8B%E7%AC%AC3%E7%AB%A0%E7%AC%94%E8%AE%B0/362a0229b6ab79d0dd5adbf3a2c37897.png" alt="image-20201110160221164"></p>
<h5 id="三操作数浮点转换指令"><a href="#三操作数浮点转换指令" class="headerlink" title="三操作数浮点转换指令"></a>三操作数浮点转换指令</h5><p><img src="/post/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E3%80%8B%E7%AC%AC3%E7%AB%A0%E7%AC%94%E8%AE%B0/9ccbe5e6e313ae3f6b0b7b8373698ebf.png" alt="image-20201110160314177"></p>
<h5 id="标量浮点算术运算"><a href="#标量浮点算术运算" class="headerlink" title="标量浮点算术运算"></a>标量浮点算术运算</h5><p><img src="/post/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E3%80%8B%E7%AC%AC3%E7%AB%A0%E7%AC%94%E8%AE%B0/d8f741dc2ac1d35590d05b5d95b60630.png" alt="image-20201110160352682"></p>
<h5 id="浮点数的位级操作"><a href="#浮点数的位级操作" class="headerlink" title="浮点数的位级操作"></a>浮点数的位级操作</h5><p><img src="/post/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E3%80%8B%E7%AC%AC3%E7%AB%A0%E7%AC%94%E8%AE%B0/e3367b1173bd3abfc4957a85765c0a65.png" alt="image-20201110160422252"></p>
<h5 id="比较浮点数值的指令"><a href="#比较浮点数值的指令" class="headerlink" title="比较浮点数值的指令"></a>比较浮点数值的指令</h5><p><img src="/post/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E3%80%8B%E7%AC%AC3%E7%AB%A0%E7%AC%94%E8%AE%B0/77c82b0ca2833fb07f330017c47b70fd.png" alt="image-20201110160511101"></p>
<h2 id="3-12-小结"><a href="#3-12-小结" class="headerlink" title="3.12 小结"></a>3.12 小结</h2><p>这一章本质上是讲述c++代码是如何优化成汇编代码的，讲述了x86-64下的汇编是什么样的，给出一些例子让我们直接的接触到“计算机是如何工作的”。</p>
<h4 id="注意："><a href="#注意：" class="headerlink" title="注意："></a><strong>注意：</strong></h4><ol>
<li><p>switch与if的区别，空间换时间。</p>
</li>
<li><p>① If else与switch对比：</p>
</li>
<li><p>② switch直接跳转，时间复杂度是O(1)，if else最坏情况遍历所有可能性，复杂度是O(n)。switch的直接跳转原理是hash表，因此，如果case常量的种类很多时，汇编代码量也会比if else大很多</p>
</li>
<li><p>③ 但是switch只能处理case为常量的情况，对非常量的情况是无能为力的。例如 if (a &gt; 1       &amp;&amp; a &lt;  100)，是无法使用switch…case来处理的。对于这种情况，如果我们真的暴力的写case 1-case100. 代码块会很大</p>
</li>
<li><p>④ 本质上是空间换时间</p>
</li>
<li><p>栈的原理，栈是真的很符合咱们的coding习惯，先入后出的原则，比如我的main函数调用func函数，在进入func前，会将一些寄存器的值保存下来，即压入栈中，然后在func中，可以放心使用这些寄存器</p>
</li>
<li><p>① 传参数6个以内，可以用register，那么程序的效率可以被提升</p>
</li>
<li><p>② 传指针，比传整个结构体要划算很多，因为传整个结构体，相当于(1)要生成相应的代码，将结构体的变量保存一份，这些代码的运行，需要消耗时间(2)这些变量会占用内存，占用空间</p>
</li>
<li><p>union与struct区别，在于union会使用变量中，最大的那一个开辟内存，而struct会整体开辟内存</p>
</li>
<li><p>struct整体一定会按照1/2/4/8对齐。此外对于struct中的某些变量也无比遵守首地址对齐，char 1      allign，short 2 allign，int float 4 allign， long double 指针， 8 allign</p>
</li>
<li><p>此外，本章带来的最大的启发是：和程序最直接相关的代码不是高级语言，比如c/c++，而是汇编代码(机器代码）。因此，在将高级语言编译成汇编的时候，编译器的好坏对于程序的性能有非常大的影响。</p>
</li>
</ol>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E7%AC%94%E8%AE%B0/" rel="tag"># 笔记</a>
              <a href="/tags/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/" rel="tag"># 深入理解计算机系统</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/post/IDA%E5%92%8COD%E7%9A%84%E4%BD%BF%E7%94%A8.html" rel="prev" title="IDA和OD的使用">
      <i class="fa fa-chevron-left"></i> IDA和OD的使用
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  

#
#                            ---------------- 本文结束 ----------------
#


          </div>
          
    
  <div class="comments">
    <div id="lv-container" data-id="city" data-uid="MTAyMC81MzU3MC8zMDA0Mw=="></div>
  </div>
  

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E4%B8%89%E7%AB%A0-%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA"><span class="nav-number">1.</span> <span class="nav-text">第三章 程序的机器级表示</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#3-2-%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A0%81"><span class="nav-number">1.1.</span> <span class="nav-text">3.2 程序编码</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E6%8A%BD%E8%B1%A1%E6%A8%A1%E5%9E%8B"><span class="nav-number">1.1.0.1.</span> <span class="nav-text">计算机的抽象模型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B1%87%E7%BC%96%E4%BB%A3%E7%A0%81%E4%B8%AD%E7%9A%84%E5%AF%84%E5%AD%98%E5%99%A8"><span class="nav-number">1.1.0.2.</span> <span class="nav-text">汇编代码中的寄存器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%BA%E5%99%A8%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B"><span class="nav-number">1.1.0.3.</span> <span class="nav-text">机器代码示例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%8D%E6%B1%87%E7%BC%96%E7%AE%80%E4%BB%8B"><span class="nav-number">1.1.0.4.</span> <span class="nav-text">反汇编简介</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-3-%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F"><span class="nav-number">1.2.</span> <span class="nav-text">3.3 数据格式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-%E8%AE%BF%E9%97%AE%E4%BF%A1%E6%81%AF"><span class="nav-number">1.2.1.</span> <span class="nav-text">3.4 访问信息</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C%E6%95%B0%E6%8C%87%E7%A4%BA%E7%AC%A6"><span class="nav-number">1.2.1.1.</span> <span class="nav-text">操作数指示符</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%95%B4%E6%95%B0%E5%AF%84%E5%AD%98%E5%99%A8"><span class="nav-number">1.2.1.1.1.</span> <span class="nav-text">整数寄存器</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%89%E7%A7%8D%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%93%8D%E4%BD%9C%E6%95%B0"><span class="nav-number">1.2.1.1.2.</span> <span class="nav-text">三种类型的操作数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C%E6%95%B0%E7%9A%84%E6%A0%BC%E5%BC%8F"><span class="nav-number">1.2.1.1.3.</span> <span class="nav-text">操作数的格式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E4%BC%A0%E9%80%81%E6%8C%87%E4%BB%A4"><span class="nav-number">1.2.1.1.4.</span> <span class="nav-text">数据传送指令</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8E%8B%E5%85%A5%E5%92%8C%E5%BC%B9%E5%87%BA%E6%A0%88%E6%95%B0%E6%8D%AE"><span class="nav-number">1.2.1.1.5.</span> <span class="nav-text">压入和弹出栈数据</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-5-%E7%AE%97%E6%95%B0%E5%92%8C%E9%80%BB%E8%BE%91%E6%93%8D%E4%BD%9C"><span class="nav-number">1.2.2.</span> <span class="nav-text">3.5 算数和逻辑操作</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8A%A0%E8%BD%BD%E6%9C%89%E6%95%88%E5%9C%B0%E5%9D%80"><span class="nav-number">1.2.2.0.1.</span> <span class="nav-text">加载有效地址</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%80%E5%85%83%E5%92%8C%E4%BA%8C%E5%85%83%E6%93%8D%E4%BD%9C"><span class="nav-number">1.2.2.0.2.</span> <span class="nav-text">一元和二元操作</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%A7%BB%E4%BD%8D%E6%93%8D%E4%BD%9C"><span class="nav-number">1.2.2.0.3.</span> <span class="nav-text">移位操作</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-6-%E6%8E%A7%E5%88%B6"><span class="nav-number">1.3.</span> <span class="nav-text">3.6 控制</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9D%A1%E4%BB%B6%E7%A0%81"><span class="nav-number">1.3.0.0.1.</span> <span class="nav-text">条件码</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AE%BF%E9%97%AE%E6%9D%A1%E4%BB%B6%E7%A0%81"><span class="nav-number">1.3.0.0.2.</span> <span class="nav-text">访问条件码</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%B7%B3%E8%BD%AC%E6%8C%87%E4%BB%A4"><span class="nav-number">1.3.0.0.3.</span> <span class="nav-text">跳转指令</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%B7%B3%E8%BD%AC%E6%8C%87%E4%BB%A4%E7%9A%84%E7%BC%96%E7%A0%81"><span class="nav-number">1.3.0.0.4.</span> <span class="nav-text">跳转指令的编码</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9D%A1%E4%BB%B6%E6%8E%A7%E5%88%B6%E5%AE%9E%E7%8E%B0%E6%9D%A1%E4%BB%B6%E5%88%86%E6%94%AF"><span class="nav-number">1.3.0.0.5.</span> <span class="nav-text">条件控制实现条件分支</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9D%A1%E4%BB%B6%E4%BC%A0%E9%80%81%E5%AE%9E%E7%8E%B0%E6%9D%A1%E4%BB%B6%E5%88%86%E6%94%AF"><span class="nav-number">1.3.0.0.6.</span> <span class="nav-text">条件传送实现条件分支</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%BE%AA%E7%8E%AF"><span class="nav-number">1.3.0.0.7.</span> <span class="nav-text">循环</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#suitch%E8%AF%AD%E5%8F%A5"><span class="nav-number">1.3.0.0.8.</span> <span class="nav-text">suitch语句</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-7-%E8%BF%87%E7%A8%8B"><span class="nav-number">1.3.0.1.</span> <span class="nav-text">3.7 过程</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E6%A0%88"><span class="nav-number">1.3.0.1.1.</span> <span class="nav-text">运行时栈</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%BD%AC%E7%A7%BB%E6%8E%A7%E5%88%B6"><span class="nav-number">1.3.0.1.2.</span> <span class="nav-text">转移控制</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E4%BC%A0%E9%80%81"><span class="nav-number">1.3.0.1.3.</span> <span class="nav-text">数据传送</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%A0%88%E4%B8%8A%E7%9A%84%E5%B1%80%E9%83%A8%E5%AD%98%E5%82%A8"><span class="nav-number">1.3.0.1.4.</span> <span class="nav-text">栈上的局部存储</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AF%84%E5%AD%98%E5%99%A8%E4%B8%AD%E7%9A%84%E5%B1%80%E9%83%A8%E5%AD%98%E5%82%A8"><span class="nav-number">1.3.0.1.5.</span> <span class="nav-text">寄存器中的局部存储</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%80%92%E5%BD%92%E8%BF%87%E7%A8%8B"><span class="nav-number">1.3.0.1.6.</span> <span class="nav-text">递归过程</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-8%E6%95%B0%E7%BB%84%E5%88%86%E9%85%8D%E5%92%8C%E8%AE%BF%E9%97%AE"><span class="nav-number">1.4.</span> <span class="nav-text">3.8数组分配和访问</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E5%8E%9F%E5%88%99"><span class="nav-number">1.4.0.0.1.</span> <span class="nav-text">基本原则</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%8C%87%E9%92%88%E8%BF%90%E7%AE%97"><span class="nav-number">1.4.0.0.2.</span> <span class="nav-text">指针运算</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="nav-number">1.4.0.0.3.</span> <span class="nav-text">二维数组</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-9-%E5%BC%82%E8%B4%A8%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">1.5.</span> <span class="nav-text">3.9 异质的数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93"><span class="nav-number">1.5.0.0.1.</span> <span class="nav-text">结构体</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%AF%B9%E9%BD%90"><span class="nav-number">1.5.0.0.2.</span> <span class="nav-text">数据对齐</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-10-%E5%9C%A8%E6%9C%BA%E5%99%A8%E7%BA%A7%E7%A8%8B%E5%BA%8F%E4%B8%AD%E5%B0%86%E6%8E%A7%E5%88%B6%E5%92%8C%E7%A8%8B%E5%BA%8F%E7%BB%93%E5%90%88%E8%B5%B7%E6%9D%A5"><span class="nav-number">1.6.</span> <span class="nav-text">3.10 在机器级程序中将控制和程序结合起来</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%90%86%E8%A7%A3%E6%8C%87%E9%92%88"><span class="nav-number">1.6.0.0.1.</span> <span class="nav-text">理解指针</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E8%B6%8A%E7%95%8C%E5%BC%95%E7%94%A8"><span class="nav-number">1.6.0.0.2.</span> <span class="nav-text">内存越界引用</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-11%E6%B5%AE%E7%82%B9%E4%BB%A3%E7%A0%81"><span class="nav-number">1.7.</span> <span class="nav-text">3.11浮点代码</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E4%BC%A0%E9%80%81%E6%8C%87%E4%BB%A4-1"><span class="nav-number">1.7.0.0.1.</span> <span class="nav-text">数据传送指令</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8F%8C%E6%93%8D%E4%BD%9C%E6%95%B0%E6%B5%AE%E7%82%B9%E8%BD%AC%E6%8D%A2%E6%8C%87%E4%BB%A4"><span class="nav-number">1.7.0.0.2.</span> <span class="nav-text">双操作数浮点转换指令</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%89%E6%93%8D%E4%BD%9C%E6%95%B0%E6%B5%AE%E7%82%B9%E8%BD%AC%E6%8D%A2%E6%8C%87%E4%BB%A4"><span class="nav-number">1.7.0.0.3.</span> <span class="nav-text">三操作数浮点转换指令</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%A0%87%E9%87%8F%E6%B5%AE%E7%82%B9%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97"><span class="nav-number">1.7.0.0.4.</span> <span class="nav-text">标量浮点算术运算</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E4%BD%8D%E7%BA%A7%E6%93%8D%E4%BD%9C"><span class="nav-number">1.7.0.0.5.</span> <span class="nav-text">浮点数的位级操作</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%AF%94%E8%BE%83%E6%B5%AE%E7%82%B9%E6%95%B0%E5%80%BC%E7%9A%84%E6%8C%87%E4%BB%A4"><span class="nav-number">1.7.0.0.6.</span> <span class="nav-text">比较浮点数值的指令</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-12-%E5%B0%8F%E7%BB%93"><span class="nav-number">1.8.</span> <span class="nav-text">3.12 小结</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B3%A8%E6%84%8F%EF%BC%9A"><span class="nav-number">1.8.0.1.</span> <span class="nav-text">注意：</span></a></li></ol></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Nizdy</p>
  <div class="site-description" itemprop="description">(눈_눈)</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">12</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/Nizdy" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Nizdy" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:1922332893@qq.com" title="E-Mail → mailto:1922332893@qq.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://qm.qq.com/cgi-bin/qm/qr?k=Lb6YI3EhGlLvHxiNJHyfIFVn6tl9668K&noverify=0" title="QQ → https:&#x2F;&#x2F;qm.qq.com&#x2F;cgi-bin&#x2F;qm&#x2F;qr?k&#x3D;Lb6YI3EhGlLvHxiNJHyfIFVn6tl9668K&amp;noverify&#x3D;0" rel="noopener" target="_blank"><i class="fa fa-fw fa-qq"></i>QQ</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Nizdy</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>

<script src="/js/utils.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

<script>
NexT.utils.loadComments(document.querySelector('#lv-container'), () => {
  window.livereOptions = {
    refer: location.pathname.replace(CONFIG.root, '').replace('index.html', '')
  };
  (function(d, s) {
    var j, e = d.getElementsByTagName(s)[0];
    if (typeof LivereTower === 'function') { return; }
    j = d.createElement(s);
    j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
    j.async = true;
    e.parentNode.insertBefore(j, e);
  })(document, 'script');
});
</script>

</body>
</html>
